# -*- coding: utf-8 -*-
"""CVML2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ro_eBs0nvdWtTVq3iBzVhpGrmalF7T1L
"""

!pip install -U -q PyDrive
!pip install -U -q nltk
!pip install -U -q gensim
import os
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

data = pd.read_csv('/root/data/data.csv')

def uploadFile():
    # 1. Authenticate and create the PyDrive client.
    auth.authenticate_user()
    gauth = GoogleAuth()
    gauth.credentials = GoogleCredentials.get_application_default()
    drive = GoogleDrive(gauth)

    # choose a local (colab) directory to store the data.
    local_download_path = os.path.expanduser('~/data')
    try:
      os.makedirs(local_download_path)
    except: pass
    file_list = drive.ListFile({'q': "'root' in parents"}).GetList()
    fname = ""
    for file in file_list:
      if(file["title"] == "data.csv"):
        print(file)
        fname = os.path.join(local_download_path, file['title'])
        f_ = drive.CreateFile({'id': file['id']})
        f_.GetContentFile(fname)

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from nltk.tokenize import sent_tokenize, word_tokenize 
import warnings 
warnings.filterwarnings(action = 'ignore') 
import gensim 
from gensim.models import Word2Vec 


class Processor(object):
    def __init__(self, data1):
        self.data = data1
        self.gun_stolen_list = []
        self.gun_type_list = []
        self.part_status_list = []
        self.part_type_list = []
        self.model2 = None
        self.model3 = None
        self.model4 = None
        self.model5 = None
        
    def process(self):
        nulldata = self.data.isnull().sum() * 1./self.data.shape[0]
        nulldata.plot(kind='bar')
        plt.show()

        dropcols = ['location_description', 'participant_name', 'participant_age_group', 'participant_relationship', 'date', 'address', 'incident_url', 'source_url', 'incident_url_fields_missing', 'incident_characteristics', 'notes', 'sources']
        self.data = self.data.drop(dropcols, axis=1)
        self.data["n_guns_involved"] = self.data["n_guns_involved"].fillna(-1).astype(int)
        colnames = ['congressional_district', 'state_house_district', 'state_senate_district']
        self.data[colnames] = self.data[colnames].astype(object)
        parse_columns = ['gun_stolen', 'gun_type', 'incident_characteristics', 'participant_age', 'participant_age_group', 'participant_gender', 'participant_name', 'participant_status', 'participant_type']

        self.data.set_index('incident_id')
        self.data['gun_stolen'] = self.data['gun_stolen'].str.replace('\|\|', ', ')
        self.data['gun_stolen'] = self.data['gun_stolen'].str.replace('::', ': ')

        self.data['participant_gender'] = self.data['participant_gender'].str.replace('\|\|', ', ')
        self.data['participant_gender'] = self.data['participant_gender'].str.replace('::', ': ')

        self.data['participant_age'] = self.data['participant_age'].str.replace('\|\|', ', ')
        self.data['participant_age'] = self.data['participant_age'].str.replace('::', ': ')

        self.data['participant_status'] = self.data['participant_status'].str.replace('\|\|', ', ')
        self.data['participant_status'] = self.data['participant_status'].str.replace('::', ': ')

        self.data['participant_type'] = self.data['participant_type'].str.replace('\|\|', ', ')
        self.data['participant_type'] = self.data['participant_type'].str.replace('::', ': ')

        self.data['gun_type'] = self.data['gun_type'].str.replace('\|\|', ', ')
        self.data['gun_type'] = self.data['gun_type'].str.replace('::', ': ')
        
        self.conv2num(self.data, "state")
        self.conv2num(self.data, "city_or_county")
        
        self.data["participant_age"] = self.data["participant_age"].apply(self.funcage)
        self.data["participant_gender"] = self.data["participant_gender"].apply(self.funcgender)


        self.data["gun_stolen"].apply(self.populateListsGunStolen)
        self.data["gun_type"].apply(self.populateListsGunType)
        self.data["participant_status"].apply(self.populateListsPartStatus)
        self.data["participant_type"].apply(self.populateListsPartType)

        self.model2 = gensim.models.Word2Vec(self.gun_stolen_list, min_count = 1,size = 1, window = 3)
        self.model3 = gensim.models.Word2Vec(self.gun_type_list, min_count = 1,size = 1, window = 3)
        self.model4 = gensim.models.Word2Vec(self.part_status_list, min_count = 1,size = 1, window = 3)
        self.model5 = gensim.models.Word2Vec(self.part_type_list, min_count = 1,size = 1, window = 3)

        self.data["gun_stolen"] = self.data["gun_stolen"].apply(self.replacer2)
        self.data["gun_type"] = self.data["gun_type"].apply(self.replacer3)
        self.data["participant_status"] = self.data["participant_status"].apply(self.replacer4)
        self.data["participant_type"] = self.data["participant_type"].apply(self.replacer5)

    def conv2num(self, data, colname):
        finaldata = []
        for state in data[:][colname]:
            finaldata.append([state])
        model1 = gensim.models.Word2Vec(finaldata, min_count = 1,size = 1, window = 1)
        dict1 = {}
        for state in model1.wv.vocab:
            dict1[state] = model1.wv[state][0]
        data[colname] = data[colname].map(dict1)

    def get_list_from_str(self, string):
        string_list = []
        strings = string.split(", ")
        for single_string in strings:
            if(": " in single_string):
                string_list.append(single_string.split(": ")[1])
        return string_list

    def funcage(self, part_age):
        if(isinstance(part_age, float)):
            return float('NaN')
        ages = part_age.split(", ")
        avg_age = 0
        for age in ages:
            if(": " in age):
                avg_age += int(age.split(": ")[1])
        return float(avg_age)/len(ages)

    def funcgender(self, part_gender):
        if(isinstance(part_gender, float)):
            return float('NaN')
        genders = part_gender.split(", ")
        avg_gender = 0
        for gender in genders:
            if(": " in gender):
                isMale = (gender.split(": ")[1] == "Male")
                if(isMale):
                    avg_gender += 1
        return float(avg_gender)/len(genders)

    def populateListsGunStolen(self, gun_stolen):
        if(isinstance(gun_stolen, float)):
            return
        self.gun_stolen_list.append(self.get_list_from_str(gun_stolen))

    def populateListsGunType(self, gun_type):
        if(isinstance(gun_type, float)):
            return
        self.gun_type_list.append(self.get_list_from_str(gun_type))

    def populateListsPartStatus(self, part_status):
        if(isinstance(part_status, float)):
            return
        self.part_status_list.append(self.get_list_from_str(part_status))

    def populateListsPartType(self, part_type):
        if(isinstance(part_type, float)):
            return
        self.part_type_list.append(self.get_list_from_str(part_type))

    def replacer2(self, col):
        if(isinstance(col, float)):
            return float('NaN')
        listwords = self.get_list_from_str(col)
        ans = 0.0
        for word in listwords:
            ans += self.model2.wv[word][0]
        if(len(listwords)==0):
            return 0.0
        return ans / float(len(listwords))

    def replacer3(self, col):
        if(isinstance(col, float)):
            return float('NaN')
        listwords = self.get_list_from_str(col)
        ans = 0.0
        for word in listwords:
            ans += self.model3.wv[word][0]
        if(len(listwords)==0):
            return 0.0
        return ans / float(len(listwords))

    def replacer4(self, col):
        if(isinstance(col, float)):
            return float('NaN')
        listwords = self.get_list_from_str(col)
        ans = 0.0
        for word in listwords:
            ans += self.model4.wv[word][0]
        if(len(listwords)==0):
            return 0.0
        return ans / float(len(listwords))

    def replacer5(self, col):
        if(isinstance(col, float)):
            return float('NaN')
        listwords = self.get_list_from_str(col)
        ans = 0.0
        for word in listwords:
            ans += self.model5.wv[word][0]
        if(len(listwords)==0):
            return 0.0
        return ans / float(len(listwords))

proc1 = Processor(data)

proc1.process()

proc1.data.to_pickle("/root/data/processed.pkl")

proc1.data.dropna(inplace=True)
X = proc1.data.copy(True)

Y = proc1.data.loc[:, "n_killed"]

X = X.drop(["n_killed", "incident_id"], axis=1)

n = X.shape[0]
split = int(n*0.8)
X_train, X_test, y_train, y_test = X[:split], X[split:], Y[:split], Y[split:]

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.wrappers.scikit_learn import KerasRegressor
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline

def model_maker():
    classifier = Sequential()
    classifier.add(Dense(units = 128, kernel_initializer = 'uniform', activation = 'relu', input_dim = X.shape[1]))
    classifier.add(Dense(units = 128, kernel_initializer = 'uniform', activation = 'relu'))
    classifier.add(Dense(units = 1))
    classifier.compile(loss='mean_squared_error', optimizer='adam', metrics=['accuracy'])
    return classifier

seed = 7
np.random.seed(seed)
# evaluate model with standardized dataset
estimator = KerasRegressor(build_fn=model_maker, epochs=100, batch_size=50, verbose=0)

kfold = KFold(n_splits=10, random_state=seed)
results = cross_val_score(estimator, X_train, y_train, cv=kfold)
print("Results: %.2f (%.2f) MSE" % (results.mean(), results.std()))

estimator.fit(X_train, y_train)
prediction = estimator.predict(X_train)

prediction_test = estimator.predict(X_test)
y_test_new = y_test.as_matrix().reshape((y_test.shape[0]))
wrong_count = 0
for i in range(y_test_new.shape[0]):
#     print(">>>>>>>>>>>  Actual Num Killed: %d  Predicted Num Killed: %d" % (y_test_new[i], round(prediction_test[i])))
    if(round(prediction_test[i]) != y_test_new[i]):
        wrong_count+=1
print("Acc: %.2f" % (float(y_test_new.shape[0]-wrong_count)/y_test_new.shape[0]*100.0))

y_train.shape